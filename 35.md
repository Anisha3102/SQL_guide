# How do you optimize a slow SQL query?

## 1. Analyze the Query Execution

- Use EXPLAIN / EXPLAIN ANALYZE / QUERY PLAN (DBMS-specific) to see how the query is executed.

- Check for full table scans, missing indexes, and expensive joins.

## 2. Optimize Indexing

- Create indexes on columns used in:

**WHERE**

**JOIN**

**ORDER BY**

**GROUP BY**- 

- Prefer covering indexes (indexes that include all required columns).

- Use composite indexes for multi-column filters.

>  Don’t over-index → slows down INSERT/UPDATE/DELETE.

## 3. Rewrite the Quer##

- Avoid SELECT * → fetch only required columns.

- Replace subqueries with JOINs or CTEs if they perform better.

- Use EXISTS instead of IN for large subqueries.

- Use UNION ALL instead of UNION if duplicates don’t matter.

- Break complex queries into smaller, staged queries.

## 4. Optimize Joins

- Ensure join columns are indexed.

- Use the right join type (INNER, LEFT) depending on need.

- Reduce unnecessary joins (e.g., joining lookup tables not needed in result).

## 5. Reduce Data Scanned

- Apply filters early (WHERE, LIMIT).

- Partition large tables and query only needed partitions.

- Use proper data types (e.g., INT instead of VARCHAR for IDs).

- Archive or delete unused historical data.

## 6. Optimize Aggregations

- Pre-aggregate data into summary tables if queries are repeated.

- Use window functions smartly instead of multiple subqueries.

- Use materialized views for expensive computations.

## 7. Caching & Query Execution

- Cache frequent queries in the application layer or use database caching.

- Avoid recalculating the same results repeatedly.

## 8. Hardware & Configuration (last resort)

- Increase memory for sorting (work_mem in Postgres, sort_buffer_size in MySQL).

- Tune DB parameters for concurrency and caching.

- Scale vertically (better CPU/RAM) or horizontally (sharding, replication).